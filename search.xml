<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java常见基础问题]]></title>
    <url>%2F2018%2Fcjqrc3nox0009pov5k7ffzmy1%2F</url>
    <content type="text"><![CDATA[Map是java中的接口，Map.Entry是Map的一个内部接口。 Map提供了一些常用方法，如keySet()、entrySet()等方法。 keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。 把这个封装到哪个对象中，就用哪个对象.class 泛型：你返回一个集合，集和里面装的什么东西 List&lt;User&gt; list=qr.query(&quot;select * from users&quot;,new BeanListHandler&lt;User&gt;(User.class)); BeanHandler:（常用）将一条记录封装到一个JavaBean中 static (静态）关键字 （共享） 被修饰的成员具备以下特点： static关键字：用于修饰成员、成员变量和成员函数 随着类的加载而加载 优先于对象存在 被所有对象所共享 可以直接被类名调用 使用注意：静态方法只能访问静态成员 主函数是静态的 静态方法不能写this，super关键字 Integer.parseInt(request.getParameter(“cp”)) 意思就是你从页面上得到cp这个变量的值，然后转变成int类型， 再赋值给currentPage这个变量。 ScalarHandler：将单个值封装、例如select count（*），求内容的条数long l = (Long)qr.query(&quot;select count(*) from book&quot;, new ScalarHandler(1)); PageBean的抽取过程 首先，Servlet从jsp获取当前页码，然后传递给Service也就是业务逻辑层。 service层接收到数据，并且设置pageSize大小; 然后调用dao层查询数据库中的总的记录条数total和查询到的分页后的数据List返回给 service层。 service层就有了以下数据：total，pageSize，pageNumber，List 通过计算可以得到totalPage和startIndex; 问题来了：当我们考虑如何将总页数，查询到的结果List集合一块返回给Servlet呢？ 一个方法无法返回两个不同类型的数据。于是我们可以将以上的数据封装到PageBean 中，通过PageBean这个JavaBean封装以上的数据，存取的时候只要操作这一个对象就行。 你导文件的这个标签中不能写入自己的代码，否则你写的代码不能用或者你导入的文件不能用 innerHTML看它的英文单词也可以明白就是里面的字符按html标记的语言格式取出来或重新设置.它是一个属性。 onblur 事件会在对象失去焦点时发生。 给有些属性赋值需要用”:”而不是”=” 调用一个对象的方法则包含(),属性则不包含 cookie的setPath方法–是对地址栏上面的地址约束，确定什么后缀下面能够使用这个cookie 如果tomcat/webapp下面有两个应用：cas和webapp_b， （1） 在cas下面设置cookie,不设置setPath，默认的默认值是生产cookie的应用路径 若在cas下面生成cookie的时候 增加一条设置正常的cookie只能在一个应用中共 享，cookie.setPath(&quot;/&quot;);或者cookie.setPath (&quot;/webapp_b/&quot;);就可以在webapp_b下面获取到cas设置的cookie了。 （2） setPath()中的参数： 是相对于应用服务器存放应用的文件夹的根目录而言的 (比如tomcat下面的webapp)，因此cookie.setPath(&quot;/&quot;); 之后，可以在webapp文件夹下的所有应用共享cookie， 而 cookie.setPath(&quot;/webapp_b/&quot;)是指cas应用设置的 cookie只能在webapp_b应用下的获得，即便是产生这 个cookie的cas应用也不可以 request.getSession().setAttribute(“usr”,username);把username回返值保存到session 当前会话中，名称为usr，只要当前会话不过期，任何地方都可以访到 ; request.setAttribute(“usr”,username);把 username的返回值保存到request当前请求中， 名称为usr，只在当前请求中访问到，其他请求中无法访问 SimpleDateFormat sdf =new SimpleDateFormat(“yyyy-MM-dd”); //定义格式化规则 Date date = new Date(); //Mon Aug 01 15:17:21 CST 2016 System.out.println(sdf.format(date)); //2016-08-01 将日期装换成字符串形式 重写父类方法，子类不能抛出比父类更多的异常 绝对路径：一般是指文件在所在盘符的位置，而且是从盘符开始算起， 如某文件位于“C:\ProgramFiles\JiangMin”下面，那么 这个路径就是它的绝对路径。 相对路径：可以理解为绝对路径的部分，且是后半部分。 由当前所处位置而定的，如当前位置是在“C:\Program Files\， 那就可以说某文件处于“JiangMin”这个文件夹下。 this.getServletContext().getRealPath(“/WEB-INF/upload”); 来获取网站的物理路径 getRealPath(&quot;/upload&quot;)也可以有参数，作用就是获取在项目根路径下的子文件夹的物 理路径。即E：/aaa/upload。既代表文件又代表目录，上传文件时把文件传入你的设置 的虚拟路径File storeDirectory=new File(directoryRealPath); request.setCharacterEncoding()：用来确保发往服务器的参数以汉字的编码来提取， 设置从request中取得的值或从数据库中取出的值。 指定后可以通过request.getParameter()获取自己想要的字符串,如果没有提前指定， 则会按照 服务器端默认的“iso-8859-1”来进行编码；该方法只对post请求有效， 对get请求无效；对于get请求，应该在server.xml中指定：URIEncoding=utf-8； 注意：在执行request.setCharacterEncoding()之前不能执行request.getParameter()方法； 原因：应该是在执行第一个getParameter()的时候，java将会按照编码分析 效。而对于GET方法提交表单是，提交的内容在URL中，一开始就已经 按照编码分析提交内容，setCharacterEncoding()自然就无效。 response.setCharacterEncoding():设置HTTP 响应的编码，用于设置服务器给客户端的数据的编码 PrintWriter out=response.getWriter(); 是一个输出流 response.getWriter(); 这个是获取了一个输出流 输出的对象是页面 这就像System.out.print（）一样 只不过这个 输出对象的是命令提示符窗口 他们都是包装好 的实际用输出流时 之前应该指向一个文件的 写代码中的低级错误： * 单词拼错 * 多加或少加空格 * 空指针异常（没有定义对象，或对象定义出错） * 导包的时候导错 B/S(Browser/Server)结构,即浏览器和服务器结构。它是对C/S结构的一种变化或者改进的结构。 C/S 结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两 端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。 区别：二者没有本质区别，之所以在C/S架构上提出B/S架构，是为了满足瘦客户端、一体化客户 端的需要，最终目的节约客户端更新、维护等的成本，及广域资源的共享。 （1）B/S属于C/S，浏览器只是特殊的客户端； （2）C/S可以使用任何通信协议，而B/S这个特殊的C/S架构规定必须实现HTTP协议； （3）浏览器是一个通用客户端，本质上开发浏览器，还是实现一个C/S系统。 @Autowired是一种函数，可以对成员变量、方法和构造函数进行标注， 来完成自动装配的工作。 @Autowired标注可以放在成员变量上，也可以放在成员变量的set方法上。 这里必须明确：@Autowired是根据类型进行自动装配的，如果需要按名称 进行装配，则需要配合@Qualifier[1]使用； mybatis中refid是什么意思 答：首先定义一个sql标签，一定要定义唯一id&lt;sql id=&quot;Base_Column_List&quot;&gt;name,age&lt;/sql&gt; 然后通过id引用&lt;select id=&quot;selectAll&quot;&gt;select &lt;include refid=&quot;Base_Column_List&quot; /&gt;from student&lt;/select&gt; 这个&lt;include refid=&quot;Base_Column_List&quot; /&gt; 会自动把上面的代码贴过来 接口和抽象类有什么区别，你选择使用接口和抽象类的依据是什么？ 接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这 两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它. 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)， 但是可以实现多个接口(吃饭接口、走路接口)。 总结几句话来说： * 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类 对象，接口变量必须指向实现所有接口方法的类对象。 * 抽象类要被子类继承，接口要被类实现。 * 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 * 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 * 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类 只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 * 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果 * 抽象类里可以没有抽象方法 * 如果一个类里有抽象方法，那么这个类只能是抽象类 * 抽象方法要被实现，所以不能是静态的，也不能是私有的。 * 接口可继承接口，并可多继承接口，但类只能单根继承。 1. 抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高 2. 抽象类可以有具体的方法 和属性, 接口只能有抽象方法和不可变常量 3. 抽象类主要用来抽象类别,接口主要用来抽象功能. 4. 抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方 法都必须是未实现的。当你关注一个事物的本质的时候，用抽象类； 当你关注一个操作的时候，用接口。抽象类的功能要远超过接口，但 是，定义抽象类的代价高。因为高级语言来说（从实际设计上来 说也是）每个类只能继承一个类。 在这个类中，你必须继承或编 写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是 它只是针对一个动作的描述。而且你可以在一个类中同时实现多个 接口。在设计阶段会降低难度的。 我们在开发mybatis时要注意四点开发规范：(1) mapper.xml中namespace等于mapper接口地址(2) mapper.java接口中的方法名和mapper.xml中statement的id一致(3) mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类 型一致。(4) mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。 pojo和javabean的区别 POJO 和JavaBean是我们常见的两个关键字，一般容易混淆， POJO全称是Plain Ordinary Java Object / Pure Old Java Object， 中文可以翻译成:普通Java类，具有一部分getter/setter 方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很 多，Java Bean是可复用的组件，对Java Bean 并没有严格的规范， 理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下， 由于 JavaBean 是被容器所创建(如 Tomcat) 的，所以JavaBean 应具有一个无参的构造器。 另外，通常 JavaBean Serializable接口用于实现 Bean 的持久性。 JavaBean是不能被跨进程访问的。 JavaBean是一种组件技术，就好像你做了一个扳，而这个扳 子会在很多地方 被拿去用，这个扳子也提供多种功能(你可以 拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。 一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。 POJO(Plain OldJava Object)这个名字用来强调它是一个普通java对象，而不 是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定 或框架(如EJB)的Java对象。理想地讲，一个POJO是一个不受任何限制的Java 对象(除了Java语言规范)。]]></content>
      <categories>
        <category>java</category>
        <category>question</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask的使用与演示（加载图片）]]></title>
    <url>%2F2018%2Fcjqrc3nog0002pov5cboawlsm%2F</url>
    <content type="text"><![CDATA[AsyncTask(异步任务） 主要作用是处理主线程与子线程之间的通信问题。 主线程非常重要，主要用加载我们的UI界面，完成系统和我们用户之间的交互，并将交互后的结果展示给用户，因此主线程又称为UI线程。 我们不能在主线程中进行耗时操作（加载网络图片或进行数据库查询），因为会阻塞我们的UI Thread,同样我们也不能在子线程当中来操作我们的UI元素，那么如果我们想要从网络上下载一个图片，又怎么把它更新到我们的UI控件上呢，这就关系到主线程和子线程之间的通信问题了。这时我们就可以用到AsyncTask。 一般情况下，当我们需要定义一个AsyncTask时，就要定义一个类来继承这个抽象类，并实现这个抽象类中的唯一的个抽象方法doInBackground，简单的总结AsyncTask的用法就是：三个泛型，四个步骤。 三个泛型 AsyncTask&lt;Params,Progress,Result&gt; Params:这个泛型指定的是我们传递给异步任务执行时的参数的类型。（通常指定的URL路经即String类型）Progress:这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。（进度条的单位通常都是Integer类型）Result:这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。 我们在定义一个类继承AsyncTask类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则将其都写成void。 四个步骤当我们执行一个异步任务的时候，其需要按照下面的4个步骤分别执行： onPreExecute（）：这个方法是在异步任务执行之前执行的，并且是在主线程当中执行，一般情况下，我们在这个方法里做一些UI控件的初始化动作，例如：弹出ProgressDialogdoInBackground（Params…params）：在onPreExecute（）方法执行完后会立即执行这个方法，它是用来处理异步任务的方法。 Android操作系统会在后台的线程池中开启一个子线程来执行我们这个方法，所以这个方法是在子线程中执行的。这个方法执行完之后，会将我们的结果发送给最后一个onPostExecute（）方法，在这个方法里，我们可以从网络当中获取数据等一些耗时操作onProgressUpdate(Progress…values):这个方法和onPreExecute方法一样都是在主线程当中执行的额，它主要是将执行的进度返回给我们的UI界面，更新我们的进度，例如：下载一张网络图片，我们要时刻显示它的进度，就可以使用这个方法来更新我们的进度。在这个方法调用之前，我们需要在doInBackground方法中调用一个publishProgress（Progress）的方法来将我们的进度时时刻刻传递给onPostUpdate方法来更新。onPostExecute（Result…result）：当我们的异步任务执行完之后就会将结果返回给这个方法，这个方法和onPreExecute，onProgressUpdate方法一样都是在主线程中操作的，我们可以将返回结果显示在UI控件上。 我们的AsyncTask抽象类只有一个抽象方法，因为，如果我们要做一个异步任务，我们必须为其开辟一个新的线程，让其完成一些操作，而在完成这个异步任务时，我们可能并不需要弹出ProgressDialog并更新进度条，也不要需要将结果更新给我们的UI界面，所以除了doInBackground方法之外的三个方法都不是必须要有的，因此我们必须要实现的方法是doInBackground方法。 在使用AsyncTask做异步任务时，必须要遵循以下原则： AsyncTask类必须要在UI Thread中加载，在Android Jelly_Bean版本之后这些都是自动完成的 execute方法必须在UI Thread当中调用 AsyncTask对象必须在UI Thread当中进行实例化 AsyncTask任务只能被执行一次 onPreExecute，doInBackground，publishProgress，onProgressUpdate，onPostExecute方法，这些都是由Android系统自动调用的，不能手动去调用。 加载一张网络图片代码展示 Activity_main.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:id=&quot;@+id/image_view&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/image_button&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;@string/picture&quot; android:layout_below=&quot;@id/image_view&quot;/&gt; &lt;/RelativeLayout&gt; AndroidManifest.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.bignerdranch.android.asynctask&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;!-- ATTENTION: This was auto-generated to add Google Play services to your project for App Indexing. See https://g.co/AppIndexing/AndroidStudio for more information. --&gt; &lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt; string.xml: &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;AsyncTask&lt;/string&gt; &lt;string name=&quot;picture&quot;&gt; 加载一张网络图片 &lt;/string&gt; &lt;/resources&gt; MainActivity.java: package com.bignerdranch.android.asynctask; import android.app.ProgressDialog;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.ImageView; import com.google.android.gms.appindexing.AppIndex;import com.google.android.gms.common.api.GoogleApiClient; import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL; public class MainActivity extends AppCompatActivity { private ImageView mImageView; private Button mButton; ProgressDialog progressDialog; private final static String IMAGE_PATH = “http://img4.imgtn.bdimg.com/it/u=3153784763,2205498087&amp;fm=27&amp;gp=0.jpg&quot;; private GoogleApiClient mClient; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImageView = (ImageView) findViewById(R.id.image_view); mButton = (Button) findViewById(R.id.image_button); mButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new MyAsyncTask().execute(IMAGE_PATH); } }); progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle(&quot;提示信息&quot;); progressDialog.setMessage(&quot;正在加载，请稍候...&quot;); progressDialog.setCancelable(false); progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); mClient = new GoogleApiClient.Builder(this).addApi(AppIndex.API).build(); } public class MyAsyncTask extends AsyncTask&lt;String, Bitmap, Bitmap&gt; { @Override public void onPreExecute() { super.onPreExecute(); progressDialog.show(); } protected Bitmap doInBackground(String... params) { return getBitmap(); } private Bitmap getBitmap() { Bitmap bitmap = null; HttpURLConnection connection = null; InputStream inputStream = null; try { URL url = new URL(IMAGE_PATH); connection = (HttpURLConnection)url.openConnection(); connection.setDoInput(true); connection.connect(); inputStream=connection.getInputStream(); bitmap= BitmapFactory.decodeStream(inputStream); } catch (IOException e) { e.printStackTrace(); } finally { if (inputStream!=null){ try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if(connection!=null){ connection.disconnect(); } } return bitmap; } public void onProgressUpdate(Bitmap values){ super.onProgressUpdate(values); } public void onPostExecute(Bitmap result){ super.onPostExecute(result); mImageView.setImageBitmap(result); progressDialog.dismiss(); } } }参考文献：AsyncTask详解]]></content>
      <categories>
        <category>Android</category>
        <category>AsyncTask</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AsyncTask</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView的用法]]></title>
    <url>%2F2018%2Fcjqrc3non0006pov5rffo8vrs%2F</url>
    <content type="text"><![CDATA[用TextView显示图片和文字可将图片与文字写在一个TextView中 android:drawableTop=&quot;@drawable/grass&quot; &lt;!--more--&gt; 用TextView显示两种颜色的字体在主活动中添加如下代码：private String source = ““ + “第一种颜色，第二种颜色，” + “百度一下\””;TextView mTextShow=(TextView)findViewById(R.id.myTextView);mTextShow.setText(Html.fromHtml(source));//将source通过Html解析返回给客户端mTextShow.setMovementMethod(LinkMovementMethod.getInstance());//不设置，点击只能是无效的 代码解释：标签：规定文本的尺寸、字体和颜色： 其中\是转义字符，用来转义“ 标签定义超链接，用于从一个页面链接到另一个页面。 元素最重要的属性是 href 属性，它指定链接的目标。 在所有浏览器中，链接的默认外观如下： 未被访问的链接带有下划线而且是蓝色的 已被访问的链接带有下划线而且是紫色的 活动链接带有下划线而且是红色的 使用SpannableString String text1 = “sometimes to say,”; String text2 = “is not to believe”; String text = text1 + text2; TextView tvtext = (TextView) findViewById(R.id.text_view1); SpannableString span = new SpannableString(text); URLSpan url = new URLSpan(“http://www.baidu.com&quot;); tvtext.setMovementMethod(LinkMovementMethod.getInstance()); span.setSpan(url, 0, 16, Spanned.SPAN_INCLUSIVE_INCLUSIVE); span.setSpan(new ForegroundColorSpan(Color.BLUE), 0, 16, Spannable.SPAN_INCLUSIVE_INCLUSIVE); span.setSpan(new ForegroundColorSpan(Color.GREEN), 16, text.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE); tvtext.setText(span); 用TextView实现文字横向滚动 &lt;TextView android:id=&quot;@+id/myTextView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:focusable=&quot;true&quot;//是否获得焦点 android:textColor=&quot;@android:color/black&quot; android:ellipsize=&quot;marquee&quot;//以跑马灯的形式出现 android:scrollHorizontally=&quot;true&quot;//横向滚动 android:marqueeRepeatLimit=&quot;marquee_forever&quot;//表示重复滚动的次数（无限次） android:focusableInTouchMode=&quot;true&quot; android:textSize=&quot;15dp&quot; android:singleLine=&quot;true&quot; android:text=&quot;@string/text&quot;&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>TextView</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextView</tag>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android王国简介]]></title>
    <url>%2F2018%2Fcjqrc3no70000pov5j5e53y1f%2F</url>
    <content type="text"><![CDATA[Android的系统架构Android大致可以分为四层架构：Linux 内核层、系统运行库层、应用框架层、应用层 Linux内核层 Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供底层驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动等。 系统运行库层 这一层通过一些C/C++库来为Android系统提供主要的特性支持。如SQLite数据库提供了数据库的支持，Webkit库提供了浏览器内核的支持等。 同样，在这一层还有Android运行时库，它主要提供一些核心库，能够允许开发者使用java语言来编写Android应用。另外Android运行时库中还包含了Dalvik虚拟机，它使每个Android应用都能够运行在独立的进程当中，并且拥有一个自己的Dalvik虚拟机实例。相较于java虚拟机，Davlik是专门为移动设备定制的 ，它针对手机内存、CPU性能有限等情况作了优化处理。 应用框架层 这一层主要提供构件应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。 应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序。 Android应用开发特色四大组件 活动（Activity）：活动是Android应用程序的门面，凡是在应用中你看得到的东西，都是放在活动中的，它主要是负责和用户交互的组件。 服务（Service）：服务相对来说比较低调，你无法看到它，但它会在后台一直默默地运行，即使用户退出了应用，服务仍然是可以继续运行的。它常用于为其它组件 提供后台服务或者监控其他组件的运行状态，经常用来执行一些耗时操作。 广播接收器（Broadcast Receiver）：广播接收器允许你的应用接收来自各处的广播消息，比如电话、短信等。当然你的应用同样也可以向外发出广播消息。其主要 是用来监听应用程序中的其它组件。 内容提供器（Content Provider）：为应用程序之间共享数据提供了可能，比如你要读取系统电话簿中的联系人，就需要内容提供器来完成。它主要是应用程序之间 实现实时数据交换。 丰富的系统控件 TextView：它主要用于在界面上显示一段文本信息。 Button：是程序用于和用户交互的一个重要组件。 EditText：它允许用户在控件里输入和编辑内容，并在程序中对这些内容进行修改。 ImageView：是用于在界面上展示图片的一种控件。它可以让我们的程序界面变的更加丰富多彩。 ProgressBar：用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。 AlertDialog：可以在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的。 ListView：允许通过手指上下滑的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据将会滚出屏幕。 SQLite数据库 Android系统自带了这种轻量级的、运算速度极快的嵌入式关系型数据库。它不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变的更加方便。 强大的多媒体 Android系统提供了强大的多媒体服务，如音乐、视频、录音、拍照等，这一切你都可以在程序中通过代码进行控制，让你的应用变的更加丰富多彩。 地理位置定位 基于位置的服务所围绕的核心就是要先确定出用户所在的位置。通常有两种技术方式可以实现：一种是GPS定位，一种是通过网络定位。GPS定位的工作原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种定位方式精确度非常高。但缺点是只能在室外使用，室内基本无法接收到卫星的信号。网络定位的工作原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，这种定位方式精确度一般，但优点在于室内你室外都可以时候用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fcjqrc3nou0008pov573792iox%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
