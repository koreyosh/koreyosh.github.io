<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[硬币兑换问题的算法分析]]></title>
    <url>%2F2019%2Fcjsokb7zp0006lwv5ym78lrrq%2F</url>
    <content type="text"><![CDATA[问题描述A 国一共发行了几种不同面值的硬币，分别是面值 1 元，2 元，5 元，10 元，20 元，50 元， 100 元。假设每种面值的硬币数量是无限的，现在你想用这些硬币凑出总面值为 n 的硬币， 同时你想让选出的硬币中，不同的面值种类尽可能多;在面值种类尽可能多的情况下，你想 让选择的硬币总数目尽可能多，请问应该怎么选择硬币呢?输入描述:第一行包含一个数字n，表示要凑出的面值。 输出描述:输出两个整数，分别表示最多能有多少种类型的硬币以及在类型最多的情况下最多能用上多少枚硬币。 解决方案一 import java.util.Scanner; public class Test { public static void main(String[] args) {int[] coin=new int[] {1,2,5,10,20,50,100};int[] sum=new int[10];Scanner sc=new Scanner(System.in); int in = sc.nextInt(); for(int i=1;i&lt;8;i++) { sum[i]=coin[i-1]+sum[i-1]; } int i=0;for(i=1;i&lt;8;i++) { if(sum[i]&gt;in) { break; }}System.out.print(i-1+” “);System.out.println(in-sum[i-1]+(i-1));}} 解决方案二package com.xidian; import java.util.Scanner; public class Test2 { public static void main(String[] args) { Scanner sc=new Scanner(System.in); int in=sc.nextInt(); if(in&gt;=188) { System.out.print(7+&quot; &quot;); System.out.println(7+(in-188)); }else if(in&gt;=88) { System.out.print(6+&quot; &quot;); System.out.println(6+(in-88)); }else if(in&gt;=38) { System.out.print(5+&quot; &quot;); System.out.println(5+(in-38)); }else if(in&gt;=18) { System.out.print(4+&quot; &quot;); System.out.println(4+(in-18)); }else if(in&gt;=8) { System.out.print(3+&quot; &quot;); System.out.println(3+(in-8)); }else if(in&gt;=3) { System.out.print(2+&quot; &quot;); System.out.println(2+(in-3)); }else { System.out.println(1+&quot; &quot;); System.out.println(in); } } }]]></content>
      <categories>
        <category>JAVA</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架整合]]></title>
    <url>%2F2018%2Fcjsokb84p000jlwv567104c03%2F</url>
    <content type="text"><![CDATA[SSM框架简介SpringmvcSpringmvc是Spring框架的一个模块，springmvc和spring无须通过中间整合进行整合。它一个基于mvc的web框架。 SpringSpring是轻量级框架，它的作用就是Bean工厂，用来管理Bean的生命周期和框架集成，它的两大核心分别是APO（面向切面编程）和IOC（控制反转）即把dao依赖注入service层，service层反转给acion层，Spring的顶层容器为BeanFactory。 MybatisMybatis是一个持久层的框架，是apache下的顶层项目。Mybatis让程序员将主要精力放在sql上，通过Mybatis提供的映射方式，自动灵活生成满足需要的sql语句。它可以将preparedStatement中的输入参数自动进行输入映射，将查询结果集灵活映射成java对象。 SSM框架SSM框架是Springmvc，Spring和Mybatis框架的整合，是标准的MVC模式，即Springmvc表现层（Web层）、Spring业务层（service层）、mybatis持久层（DAO层）。Spring将各层进行整合：通过Spring管理持久层的mapper（相当于dao接口）；通过Spring管理业务层的service ，service中可以调用mapper接口；Spring进行事务控制，通过Spring管理表现层的Handler。Handler中可以调用service接口，maper、service、Handler都是javabean。 整合步骤1.Mybatis和Spring进行整合，通过Spring管理mapper接口，使用mapper扫描器自动扫描mapper接口在Spring中进行注册。2.通过Spring管理Service接口，使用配置的方式将Service接口配置在Spring配置文件中，实现事务控制。3.由于Springmvc是Spring的模块，所以无须整合这两个。 Spring和Mybatis整合 把Mybatis核心配置文件中的数据库连接配置直接写在Spring核心配置文件中 把Mybatis的SqlSessionFactory对象的创建交给Spring管理 配置：在服务器启动时加载Spring核心配置文件，创建出包含SqlSessionFactory对象在内的一系列对象。]]></content>
      <categories>
        <category>JAVA</category>
        <category>框架</category>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>框架</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构常见基础问题]]></title>
    <url>%2F2018%2Fcjsokb84f000ilwv5wb8wcx54%2F</url>
    <content type="text"><![CDATA[关于算法的时间复杂度很多都用包含O(logN)这样的描述，但是却没有明确说logN的底数究竟是多少?答：算法中log级别的时间复杂度都是由于使用了分治思想,这个底数直接由分治的复杂度决定。 如果采用二分法,那么就会以2为底数,三分法就会以3为底数,其他亦然。 不过无论底数是什么,log级别的渐进意义是一样的。 也就是说该算法的时间复杂度的增长与处理数据多少的增长的关系是一样的。 我们先考虑O(logx(n))和O(logy(n))，x!=y，我们是在考虑n趋于无穷的情况。 求当n趋于无穷大时logx(n)/logy(n)的极限可以发现，极限等于lny/lnx，也就是一个常数， 也就是说，在n趋于无穷大的时候，这两个东西仅差一个常数。 所以从研究算法的角度log的底数不重要。 最后，结合上面，我也说一下关于大O的定义（算法导论28页的定义）， 注意把这个定义和高等数学中的极限部分做比较， 显然可以发现，这里的定义正是体现了一个极限的思想， 假设我们将n0取一个非常大的数字， 显然，当n大于n0的时候，我们可以发现任意底数的一个对数函数其实都相差一个常数倍而已。 所以书上说写的O（logn）已经可以表达所有底数的对数了，就像O(n^2)一样。 Java泛型－类型擦除答： Java 泛型（Generic）的引入加强了参数类型的安全性，减少了类型的转换，但有一点需要注 意：Java 的泛型在编译器有效，在运行期被删除，也就是说所有泛型参数类型在编译后都会被 清除掉，看下面一个列子，代码如下： public class Foo { public void listMethod(List&lt;String&gt; stringList){ } public void listMethod(List&lt;Integer&gt; intList) { } } 代码很简单，看起来没什么问题，但是编译器却报出如下错误信息： Method listMethod(List&lt;String&gt;) has the same erasure listMethod(List&lt;E&gt;) as another method in type Foo 此错误的意思是说listMethod(List&lt;String&gt;) 方法在编译时擦除类型后的方法是listMethod(List&lt;E&gt;)，它与另外一个方法重复，也就是方法签名重复。反编译之后的方法代码如下： public void listMethod(List list) { } 从上面代码可以看出 Java 编译后的字节码中已经没有泛型的任何信息，在编译后所有的泛型类型 都会做相应的转化，转化如下： List&lt;String&gt;、List&lt;T&gt; 擦除后的类型为 List。 List&lt;String&gt;[]、List&lt;T&gt;[] 擦除后的类型为 List[]。 List&lt;? extends E&gt;、List&lt;? super E&gt; 擦除后的类型为 List&lt;E&gt;。 List&lt;T extends Serialzable &amp; Cloneable&gt; 擦除后类型为 List&lt;Serializable&gt;。 Java 为什么这么处理呢？有以下两个原因： 1. 避免 JVM 的大换血。如果 JVM 将泛型类型延续到运行期，那么到运行期时 JVM 就 需要进行大量的重构工作了，提高了运行期的效率。 2. 版本兼容。 在编译期擦除可以更好地支持原生类型（Raw Type）。 明白了 Java 泛型是类型擦除的，下面的问题就很好理解了： （1） 泛型的 class 对象是相同的 每个类都有一个 class 属性，泛型化不会改变 class 属性的返回值，例如： public static void main(String[] args) { List&lt;String&gt; ls = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); System.out.println(ls.getClass() == li.getClass()); } 代码返回值为 true，原因很简单，List 和 List 擦除后的类型都是 List。 （2） 泛型数组初始化时不能声明泛型类型 如下代码编译时通不过： List&lt;String&gt;[] list = new List&lt;String&gt;[]; 在这里可以声明一个带有泛型参数的数组，但是不能初始化该数组，因为执行了类型擦除操 作后，List[] 与 List[] 就是同一回事了，编译器拒绝如此声明。 （3） instanceof 不允许存在泛型参数 以下代码不能通过编译，原因一样，泛型类型被擦除了。 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); System.out.println(list instanceof List&lt;String&gt;) 完全二叉树答：若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。 完全二叉树是由满二叉树而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树。 (1)所有的叶结点都出现在第k层或k-l层（层次最大的两层） (2)对任一结点，如果其右子树的最大层次为L，则其左子树的最大层次为L或L+l。 一棵二叉树至多只有最下面的两层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。 特点: 1. 只允许最后一层有空缺结点且空缺在右边，即叶子结点只能在层次最大的两层上出； 2. 对任一结点，如果其右子树的深度为j，则其左子树的深度必为j或j+1。 即度为1的点只有1个或0个 算法思路： 判断一棵树是否是完全二叉树的思路 如果树为空，则直接返回错 如果树不为空：层序遍历二叉树 2.1&gt;如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列； 2.2&gt;如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉； 2.3&gt;如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空；则该节点之后的队列中的结点都为叶子节点；该树才是完全二叉树，否则就不是完全二叉树 二叉树公式答： 1、一般二叉树的性质 性质1、在非空二叉树的i层上，至多有2^i个结点。 性质2、高度为K的二叉树中，最多有2^(k+1)-1个结点。 性质3、对于任何一棵非空的二叉树，如果叶结点的个数为n0，度为2的结点个数为n2，则有n0=n2+1 2、完全二叉树 定义：如果一棵二叉树中，只有最下面的两层结点度数小于2，其余各层结点度数都等于2，并且最下面一层的结点，都集中在该层最左边的若干位置上，则此二叉树称为完全二叉树。 性质1、具有n个结点的完全二叉树的高度k为[log^2n]。 性质2、对于具有n个结点的完全二叉树，如果按照从上（根结点）到下(叶结点)和从左到右的顺序对二叉树中的所有结点从0开始到n-1进行编号，则对于任意的下标为i的结点，有： （1）如果i=0，则它是根结点，它没有父结点；如果i&gt;0,则它的父结点的下标为（i-1）/2。 （2）如果2i+1=n-1，则下标为i的结点的左子结点的下标为2i+1；否则，下标为i的结点没有左子结点。 （3）如果2i+2=n-1，则下标为i的结点的右子结点的下标为2i+2；否则，下标为i的结点没有右子结点。 3、满二叉树 定义：如果一棵二叉的任何结点或者是树叶，或有两棵非空子树，则此二叉树称作满二叉树。 性质：在满二叉树中，叶结点的个数比分支结点个数多1。 4、扩充二叉树 定义：扩充二叉树是对一个已有二叉树的扩充，扩充后原二叉树的结点都变为度数为2的分支结点。也是就是说，如果原结点的度数为2，则不变；度数为1，则增加一个分支；度数为0，则增加两个分支。 性质1、在扩充二叉树中，外部结点的个数比内部结点的个数多1。 性质2、对任意扩充二叉树，外部路径长度E和内部路径长度I之间满足以下关系：E=I+2n，其中n是内部结点个数]]></content>
      <categories>
        <category>JAVA</category>
        <category>算法</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java易错面试题总结及解析]]></title>
    <url>%2F2018%2Fcjsokb82h000dlwv5dbuecamc%2F</url>
    <content type="text"><![CDATA[1) 下面程序的运行结果是什么（）class HelloA { public HelloA() { System.out.println(“HelloA”); } { System.out.println(“I’m A class”); } static { System.out.println(“static A”); } public class HelloB extends HelloA { public HelloB() { System.out.println(“HelloB”); } { System.out.println(“I’m B class”); } static { System.out.println(“static B”); } public static void main(String[] args) { System.out.println(&quot;-------main start-------&quot;); new HelloB(); new HelloB(); System.out.println(&quot;-------main end-------&quot;); } 答案：static Astatic B——-main start——-I’m A classHelloAI’m B classHelloBI’m A classHelloAI’m B class HelloB ——-main end——- 解析：本题考察的是对象的初始化顺序，此题中涉及到了静态代码块，构造语句块和构造函数。 对象的初始化过程从父类开始依次往下执行，首先是静态代码块，然后是构造语句块，最 后是构造函数。 静态代码块随着类的加载而加载，而且只加载一次 构造代码块是在对象创建前开始执行 构造函数是随着对象的创建而加载，对象每创建一次，便加载一次。 2) 阅读 Shape 和 Circle 两个类的定义。在序列化一个 Circle 的对象 circle 到文件时，下面哪个字段会被保存到文件中？ ( ) 复制代码 class Shape { public String name; } class Circle extends Shape implements Serializable{ private float radius; transient int color; public static String type = &quot;Circle&quot;; }复制代码 A name B radius C color D type 答案：B解析：当父类序列化时，子类会自动序列化 当子类序列化，而父类没有序列化时，父类的属性是直接跳过不保存的 序列化会忽略静态变量的状态，即序列化不保存静态变量的状态 transient后的变量也不能够序列化 3）子类继承父类，正确的是 a) 子类能够继承父类的私有方法和私有状态 b) 子类能够继承父类的 protected 方法，但不能继承父类的 protected 状态 c)子类能够继承父类的 protected 方法，也能够继承父类的 protected 状态 d) 子类能够继承父类的非私有方法和非私有状态 答案：C解析： 作用域 当前类 同一package 子孙类 其他package public √ √ √ √ protected √ √ √ × friendly √ √ × × private √ × × × 4）. 0.6332的数据类型是（） A float B double C Float D Double 答案:B解析：一般情况下，我们默认是double型，如果是float型需要加上f显示说明 即0.6332f 5) 下面程序能正常运行吗（） 复制代码 public class NULL { public static void haha(){ System.out.println(&quot;haha&quot;); } public static void main(String[] args) { ((NULL)null).haha(); } } 答案：能正常运行 解析：输出为haha，因为null值可以强制转换为任何java类类型，例如：（String）null 也是合法的。但null强制转换后是无效对象，其返回值还是null，而static方法的 调用是和类名输绑定的，不借助任何对象访问，所以可以正确输出。相反，没有 static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错误。]]></content>
      <categories>
        <category>JAVA</category>
        <category>面试</category>
        <category>question</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
        <tag>question</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java常见基础问题]]></title>
    <url>%2F2018%2Fcjsokb8130009lwv5n98ejoe1%2F</url>
    <content type="text"><![CDATA[Map是java中的接口，Map.Entry是Map的一个内部接口。 Map提供了一些常用方法，如keySet()、entrySet()等方法。 keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。 Map.Entry是Map声明的一个内部接口，此接口为泛型，定义为Entry&lt;K,V&gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue方法。 把这个封装到哪个对象中，就用哪个对象.class 泛型：你返回一个集合，集和里面装的什么东西 List&lt;User&gt; list=qr.query(&quot;select * from users&quot;,new BeanListHandler&lt;User&gt;(User.class)); BeanHandler:（常用）将一条记录封装到一个JavaBean中 static (静态）关键字 （共享） 被修饰的成员具备以下特点： static关键字：用于修饰成员、成员变量和成员函数 随着类的加载而加载 优先于对象存在 被所有对象所共享 可以直接被类名调用 使用注意：静态方法只能访问静态成员 主函数是静态的 静态方法不能写this，super关键字 Integer.parseInt(request.getParameter(“cp”)) 意思就是你从页面上得到cp这个变量的值，然后转变成int类型， 再赋值给currentPage这个变量。 ScalarHandler：将单个值封装、例如select count（*），求内容的条数long l = (Long)qr.query(&quot;select count(*) from book&quot;, new ScalarHandler(1)); PageBean的抽取过程 首先，Servlet从jsp获取当前页码，然后传递给Service也就是业务逻辑层。 service层接收到数据，并且设置pageSize大小; 然后调用dao层查询数据库中的总的记录条数total和查询到的分页后的数据List返回给 service层。 service层就有了以下数据：total，pageSize，pageNumber，List 通过计算可以得到totalPage和startIndex; 问题来了：当我们考虑如何将总页数，查询到的结果List集合一块返回给Servlet呢？ 一个方法无法返回两个不同类型的数据。于是我们可以将以上的数据封装到PageBean 中，通过PageBean这个JavaBean封装以上的数据，存取的时候只要操作这一个对象就行。 你导文件的这个标签中不能写入自己的代码，否则你写的代码不能用或者你导入的文件不能用 innerHTML看它的英文单词也可以明白就是里面的字符按html标记的语言格式取出来或重新设置.它是一个属性。 onblur 事件会在对象失去焦点时发生。 给有些属性赋值需要用”:”而不是”=” 调用一个对象的方法则包含(),属性则不包含 cookie的setPath方法–是对地址栏上面的地址约束，确定什么后缀下面能够使用这个cookie 如果tomcat/webapp下面有两个应用：cas和webapp_b， （1） 在cas下面设置cookie,不设置setPath，默认的默认值是生产cookie的应用路径 若在cas下面生成cookie的时候 增加一条设置正常的cookie只能在一个应用中共 享，cookie.setPath(&quot;/&quot;);或者cookie.setPath (&quot;/webapp_b/&quot;);就可以在webapp_b下面获取到cas设置的cookie了。 （2） setPath()中的参数： 是相对于应用服务器存放应用的文件夹的根目录而言的 (比如tomcat下面的webapp)，因此cookie.setPath(&quot;/&quot;); 之后，可以在webapp文件夹下的所有应用共享cookie， 而 cookie.setPath(&quot;/webapp_b/&quot;)是指cas应用设置的 cookie只能在webapp_b应用下的获得，即便是产生这 个cookie的cas应用也不可以 request.getSession().setAttribute(“usr”,username);把username回返值保存到session 当前会话中，名称为usr，只要当前会话不过期，任何地方都可以访到 ; request.setAttribute(“usr”,username);把 username的返回值保存到request当前请求中， 名称为usr，只在当前请求中访问到，其他请求中无法访问 SimpleDateFormat sdf =new SimpleDateFormat(“yyyy-MM-dd”); //定义格式化规则 Date date = new Date(); //Mon Aug 01 15:17:21 CST 2016 System.out.println(sdf.format(date)); //2016-08-01 将日期装换成字符串形式 重写父类方法，子类不能抛出比父类更多的异常 绝对路径：一般是指文件在所在盘符的位置，而且是从盘符开始算起， 如某文件位于“C:\ProgramFiles\JiangMin”下面，那么 这个路径就是它的绝对路径。 相对路径：可以理解为绝对路径的部分，且是后半部分。 由当前所处位置而定的，如当前位置是在“C:\Program Files\， 那就可以说某文件处于“JiangMin”这个文件夹下。 this.getServletContext().getRealPath(“/WEB-INF/upload”); 来获取网站的物理路径 getRealPath(&quot;/upload&quot;)也可以有参数，作用就是获取在项目根路径下的子文件夹的物 理路径。即E：/aaa/upload。既代表文件又代表目录，上传文件时把文件传入你的设置 的虚拟路径File storeDirectory=new File(directoryRealPath); request.setCharacterEncoding()：用来确保发往服务器的参数以汉字的编码来提取， 设置从request中取得的值或从数据库中取出的值。 指定后可以通过request.getParameter()获取自己想要的字符串,如果没有提前指定， 则会按照 服务器端默认的“iso-8859-1”来进行编码；该方法只对post请求有效， 对get请求无效；对于get请求，应该在server.xml中指定：URIEncoding=utf-8； 注意：在执行request.setCharacterEncoding()之前不能执行request.getParameter()方法； 原因：应该是在执行第一个getParameter()的时候，java将会按照编码分析 效。而对于GET方法提交表单是，提交的内容在URL中，一开始就已经 按照编码分析提交内容，setCharacterEncoding()自然就无效。 response.setCharacterEncoding():设置HTTP 响应的编码，用于设置服务器给客户端的数据的编码 PrintWriter out=response.getWriter(); 是一个输出流 response.getWriter(); 这个是获取了一个输出流 输出的对象是页面 这就像System.out.print（）一样 只不过这个 输出对象的是命令提示符窗口 他们都是包装好 的实际用输出流时 之前应该指向一个文件的 写代码中的低级错误： * 单词拼错 * 多加或少加空格 * 空指针异常（没有定义对象，或对象定义出错） * 导包的时候导错 B/S(Browser/Server)结构,即浏览器和服务器结构。它是对C/S结构的一种变化或者改进的结构。 C/S 结构，即大家熟知的客户机和服务器结构。它是软件系统体系结构，通过它可以充分利用两 端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通讯开销。 区别：二者没有本质区别，之所以在C/S架构上提出B/S架构，是为了满足瘦客户端、一体化客户 端的需要，最终目的节约客户端更新、维护等的成本，及广域资源的共享。 （1）B/S属于C/S，浏览器只是特殊的客户端； （2）C/S可以使用任何通信协议，而B/S这个特殊的C/S架构规定必须实现HTTP协议； （3）浏览器是一个通用客户端，本质上开发浏览器，还是实现一个C/S系统。 @Autowired是一种函数，可以对成员变量、方法和构造函数进行标注， 来完成自动装配的工作。 @Autowired标注可以放在成员变量上，也可以放在成员变量的set方法上。 这里必须明确：@Autowired是根据类型进行自动装配的，如果需要按名称 进行装配，则需要配合@Qualifier[1]使用； mybatis中refid是什么意思 答：首先定义一个sql标签，一定要定义唯一的 id&lt;sql id=&quot;Base_Column_List&quot;&gt;name,age&lt;/sql&gt; 然后通过id引用&lt;select id=&quot;selectAll&quot;&gt;select &lt;include refid=&quot;Base_Column_List&quot; /&gt;from student&lt;/select&gt; 这个&lt;include refid=&quot;Base_Column_List&quot; /&gt; 会自动把上面的代码贴过来 接口和抽象类有什么区别，你选择使用接口和抽象类的依据是什么？ 接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。 抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这 两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。 人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它. 所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)， 但是可以实现多个接口(吃饭接口、走路接口)。 总结几句话来说： * 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类 对象，接口变量必须指向实现所有接口方法的类对象。 * 抽象类要被子类继承，接口要被类实现。 * 接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现 * 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 * 抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类 只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。 * 抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果 * 抽象类里可以没有抽象方法 * 如果一个类里有抽象方法，那么这个类只能是抽象类 * 抽象方法要被实现，所以不能是静态的，也不能是私有的。 * 接口可继承接口，并可多继承接口，但类只能单根继承。 1. 抽象类 和 接口 都是用来抽象具体对象的. 但是接口的抽象级别最高 2. 抽象类可以有具体的方法 和属性, 接口只能有抽象方法和不可变常量 3. 抽象类主要用来抽象类别,接口主要用来抽象功能. 4. 抽象类中，且不包含任何实现，派生类必须覆盖它们。接口中所有方 法都必须是未实现的。当你关注一个事物的本质的时候，用抽象类； 当你关注一个操作的时候，用接口。抽象类的功能要远超过接口，但 是，定义抽象类的代价高。因为高级语言来说（从实际设计上来 说也是）每个类只能继承一个类。 在这个类中，你必须继承或编 写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是 它只是针对一个动作的描述。而且你可以在一个类中同时实现多个 接口。在设计阶段会降低难度的。 我们在开发mybatis时要注意四点开发规范：(1) mapper.xml中namespace等于mapper接口地址(2) mapper.java接口中的方法名和mapper.xml中statement的id一致(3) mapper.java接口中的方法输入参数类型和mapper.xml中statement的parameterType指定的类 型一致。(4) mapper.java接口中的方法返回值类型和mapper.xml中statement的resultType指定的类型一致。 pojo和javabean的区别 POJO 和JavaBean是我们常见的两个关键字，一般容易混淆， POJO全称是Plain Ordinary Java Object / Pure Old Java Object， 中文可以翻译成:普通Java类，具有一部分getter/setter 方法的那种类就可以称作POJO，但是JavaBean则比 POJO复杂很 多，Java Bean是可复用的组件，对Java Bean 并没有严格的规范， 理论上讲，任何一个 Java 类都可以是一个 Bean 。但通常情况下， 由于 JavaBean 是被容器所创建(如 Tomcat) 的，所以JavaBean 应具有一个无参的构造器。 另外，通常 JavaBean Serializable接口用于实现 Bean 的持久性。 JavaBean是不能被跨进程访问的。 JavaBean是一种组件技术，就好像你做了一个扳，而这个扳 子会在很多地方 被拿去用，这个扳子也提供多种功能(你可以 拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。 一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。 POJO(Plain OldJava Object)这个名字用来强调它是一个普通java对象，而不 是一个特殊的对象，其主要用来指代那些没有遵从特定的Java对象模型、约定 或框架(如EJB)的Java对象。理想地讲，一个POJO是一个不受任何限制的Java 对象(除了Java语言规范)。]]></content>
      <categories>
        <category>JAVA</category>
        <category>question</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask的使用与演示（加载图片）]]></title>
    <url>%2F2018%2Fcjsokb859000mlwv57soeysy8%2F</url>
    <content type="text"><![CDATA[AsyncTask(异步任务） 主要作用是处理主线程与子线程之间的通信问题。 主线程非常重要，主要用加载我们的UI界面，完成系统和我们用户之间的交互，并将交互后的结果展示给用户，因此主线程又称为UI线程。 我们不能在主线程中进行耗时操作（加载网络图片或进行数据库查询），因为会阻塞我们的UI Thread,同样我们也不能在子线程当中来操作我们的UI元素，那么如果我们想要从网络上下载一个图片，又怎么把它更新到我们的UI控件上呢，这就关系到主线程和子线程之间的通信问题了。这时我们就可以用到AsyncTask。 一般情况下，当我们需要定义一个AsyncTask时，就要定义一个类来继承这个抽象类，并实现这个抽象类中的唯一的个抽象方法doInBackground，简单的总结AsyncTask的用法就是：三个泛型，四个步骤。 三个泛型 AsyncTask&lt;Params,Progress,Result&gt; Params:这个泛型指定的是我们传递给异步任务执行时的参数的类型。（通常指定的URL路经即String类型）Progress:这个泛型指定的是我们的异步任务在执行的时候将执行的进度返回给UI线程的参数的类型。（进度条的单位通常都是Integer类型）Result:这个泛型指定的异步任务执行完后返回给UI线程的结果的类型。 我们在定义一个类继承AsyncTask类的时候，必须要指定好这三个泛型的类型，如果都不指定的话，则将其都写成void。 四个步骤当我们执行一个异步任务的时候，其需要按照下面的4个步骤分别执行： onPreExecute（）：这个方法是在异步任务执行之前执行的，并且是在主线程当中执行，一般情况下，我们在这个方法里做一些UI控件的初始化动作，例如：弹出ProgressDialogdoInBackground（Params…params）：在onPreExecute（）方法执行完后会立即执行这个方法，它是用来处理异步任务的方法。 Android操作系统会在后台的线程池中开启一个子线程来执行我们这个方法，所以这个方法是在子线程中执行的。这个方法执行完之后，会将我们的结果发送给最后一个onPostExecute（）方法，在这个方法里，我们可以从网络当中获取数据等一些耗时操作onProgressUpdate(Progress…values):这个方法和onPreExecute方法一样都是在主线程当中执行的额，它主要是将执行的进度返回给我们的UI界面，更新我们的进度，例如：下载一张网络图片，我们要时刻显示它的进度，就可以使用这个方法来更新我们的进度。在这个方法调用之前，我们需要在doInBackground方法中调用一个publishProgress（Progress）的方法来将我们的进度时时刻刻传递给onPostUpdate方法来更新。onPostExecute（Result…result）：当我们的异步任务执行完之后就会将结果返回给这个方法，这个方法和onPreExecute，onProgressUpdate方法一样都是在主线程中操作的，我们可以将返回结果显示在UI控件上。 我们的AsyncTask抽象类只有一个抽象方法，因为，如果我们要做一个异步任务，我们必须为其开辟一个新的线程，让其完成一些操作，而在完成这个异步任务时，我们可能并不需要弹出ProgressDialog并更新进度条，也不要需要将结果更新给我们的UI界面，所以除了doInBackground方法之外的三个方法都不是必须要有的，因此我们必须要实现的方法是doInBackground方法。 在使用AsyncTask做异步任务时，必须要遵循以下原则： AsyncTask类必须要在UI Thread中加载，在Android Jelly_Bean版本之后这些都是自动完成的 execute方法必须在UI Thread当中调用 AsyncTask对象必须在UI Thread当中进行实例化 AsyncTask任务只能被执行一次 onPreExecute，doInBackground，publishProgress，onProgressUpdate，onPostExecute方法，这些都是由Android系统自动调用的，不能手动去调用。 加载一张网络图片代码展示 Activity_main.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; android:id=&quot;@+id/image_view&quot; android:layout_centerInParent=&quot;true&quot;/&gt; &lt;Button android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/image_button&quot; android:layout_centerInParent=&quot;true&quot; android:text=&quot;@string/picture&quot; android:layout_below=&quot;@id/image_view&quot;/&gt; &lt;/RelativeLayout&gt; AndroidManifest.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.bignerdranch.android.asynctask&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;!-- ATTENTION: This was auto-generated to add Google Play services to your project for App Indexing. See https://g.co/AppIndexing/AndroidStudio for more information. --&gt; &lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot;/&gt; &lt;/application&gt; &lt;/manifest&gt; string.xml: &lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;AsyncTask&lt;/string&gt; &lt;string name=&quot;picture&quot;&gt; 加载一张网络图片 &lt;/string&gt; &lt;/resources&gt; MainActivity.java: package com.bignerdranch.android.asynctask; import android.app.ProgressDialog;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.AsyncTask;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.ImageView; import com.google.android.gms.appindexing.AppIndex;import com.google.android.gms.common.api.GoogleApiClient; import java.io.IOException;import java.io.InputStream;import java.net.HttpURLConnection;import java.net.URL; public class MainActivity extends AppCompatActivity { private ImageView mImageView; private Button mButton; ProgressDialog progressDialog; private final static String IMAGE_PATH = “http://img4.imgtn.bdimg.com/it/u=3153784763,2205498087&amp;fm=27&amp;gp=0.jpg&quot;; private GoogleApiClient mClient; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mImageView = (ImageView) findViewById(R.id.image_view); mButton = (Button) findViewById(R.id.image_button); mButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new MyAsyncTask().execute(IMAGE_PATH); } }); progressDialog = new ProgressDialog(MainActivity.this); progressDialog.setTitle(&quot;提示信息&quot;); progressDialog.setMessage(&quot;正在加载，请稍候...&quot;); progressDialog.setCancelable(false); progressDialog.setProgressStyle(ProgressDialog.STYLE_SPINNER); mClient = new GoogleApiClient.Builder(this).addApi(AppIndex.API).build(); } public class MyAsyncTask extends AsyncTask&lt;String, Bitmap, Bitmap&gt; { @Override public void onPreExecute() { super.onPreExecute(); progressDialog.show(); } protected Bitmap doInBackground(String... params) { return getBitmap(); } private Bitmap getBitmap() { Bitmap bitmap = null; HttpURLConnection connection = null; InputStream inputStream = null; try { URL url = new URL(IMAGE_PATH); connection = (HttpURLConnection)url.openConnection(); connection.setDoInput(true); connection.connect(); inputStream=connection.getInputStream(); bitmap= BitmapFactory.decodeStream(inputStream); } catch (IOException e) { e.printStackTrace(); } finally { if (inputStream!=null){ try { inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if(connection!=null){ connection.disconnect(); } } return bitmap; } public void onProgressUpdate(Bitmap values){ super.onProgressUpdate(values); } public void onPostExecute(Bitmap result){ super.onPostExecute(result); mImageView.setImageBitmap(result); progressDialog.dismiss(); } } }参考文献：AsyncTask详解]]></content>
      <categories>
        <category>Android</category>
        <category>AsyncTask</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>AsyncTask</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextView的用法]]></title>
    <url>%2F2018%2Fcjsokb7yb0002lwv5l6g2vpg5%2F</url>
    <content type="text"><![CDATA[用TextView显示图片和文字可将图片与文字写在一个TextView中 android:drawableTop=&quot;@drawable/grass&quot; &lt;!--more--&gt; 用TextView显示两种颜色的字体在主活动中添加如下代码：private String source = ““ + “第一种颜色，第二种颜色，” + “百度一下\””;TextView mTextShow=(TextView)findViewById(R.id.myTextView);mTextShow.setText(Html.fromHtml(source));//将source通过Html解析返回给客户端mTextShow.setMovementMethod(LinkMovementMethod.getInstance());//不设置，点击只能是无效的 代码解释：标签：规定文本的尺寸、字体和颜色： 其中\是转义字符，用来转义“ 标签定义超链接，用于从一个页面链接到另一个页面。 元素最重要的属性是 href 属性，它指定链接的目标。 在所有浏览器中，链接的默认外观如下： 未被访问的链接带有下划线而且是蓝色的 已被访问的链接带有下划线而且是紫色的 活动链接带有下划线而且是红色的 使用SpannableString String text1 = “sometimes to say,”; String text2 = “is not to believe”; String text = text1 + text2; TextView tvtext = (TextView) findViewById(R.id.text_view1); SpannableString span = new SpannableString(text); URLSpan url = new URLSpan(“http://www.baidu.com&quot;); tvtext.setMovementMethod(LinkMovementMethod.getInstance()); span.setSpan(url, 0, 16, Spanned.SPAN_INCLUSIVE_INCLUSIVE); span.setSpan(new ForegroundColorSpan(Color.BLUE), 0, 16, Spannable.SPAN_INCLUSIVE_INCLUSIVE); span.setSpan(new ForegroundColorSpan(Color.GREEN), 16, text.length(), Spannable.SPAN_EXCLUSIVE_INCLUSIVE); tvtext.setText(span); 用TextView实现文字横向滚动 &lt;TextView android:id=&quot;@+id/myTextView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:focusable=&quot;true&quot;//是否获得焦点 android:textColor=&quot;@android:color/black&quot; android:ellipsize=&quot;marquee&quot;//以跑马灯的形式出现 android:scrollHorizontally=&quot;true&quot;//横向滚动 android:marqueeRepeatLimit=&quot;marquee_forever&quot;//表示重复滚动的次数（无限次） android:focusableInTouchMode=&quot;true&quot; android:textSize=&quot;15dp&quot; android:singleLine=&quot;true&quot; android:text=&quot;@string/text&quot;&gt;]]></content>
      <categories>
        <category>Android</category>
        <category>TextView</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextView</tag>
        <tag>font</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android王国简介]]></title>
    <url>%2F2018%2Fcjsokb7x70000lwv5eh6jscax%2F</url>
    <content type="text"><![CDATA[Android的系统架构Android大致可以分为四层架构：Linux 内核层、系统运行库层、应用框架层、应用层 Linux内核层 Android系统是基于Linux内核的，这一层为Android设备的各种硬件提供底层驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动等。 系统运行库层 这一层通过一些C/C++库来为Android系统提供主要的特性支持。如SQLite数据库提供了数据库的支持，Webkit库提供了浏览器内核的支持等。 同样，在这一层还有Android运行时库，它主要提供一些核心库，能够允许开发者使用java语言来编写Android应用。另外Android运行时库中还包含了Dalvik虚拟机，它使每个Android应用都能够运行在独立的进程当中，并且拥有一个自己的Dalvik虚拟机实例。相较于java虚拟机，Davlik是专门为移动设备定制的 ，它针对手机内存、CPU性能有限等情况作了优化处理。 应用框架层 这一层主要提供构件应用程序时可能用到的各种API，Android自带的一些核心应用就是使用这些API完成的，开发者也可以通过使用这些API来构建自己的应用程序。 应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序。 Android应用开发特色四大组件 活动（Activity）：活动是Android应用程序的门面，凡是在应用中你看得到的东西，都是放在活动中的，它主要是负责和用户交互的组件。 服务（Service）：服务相对来说比较低调，你无法看到它，但它会在后台一直默默地运行，即使用户退出了应用，服务仍然是可以继续运行的。它常用于为其它组件 提供后台服务或者监控其他组件的运行状态，经常用来执行一些耗时操作。 广播接收器（Broadcast Receiver）：广播接收器允许你的应用接收来自各处的广播消息，比如电话、短信等。当然你的应用同样也可以向外发出广播消息。其主要 是用来监听应用程序中的其它组件。 内容提供器（Content Provider）：为应用程序之间共享数据提供了可能，比如你要读取系统电话簿中的联系人，就需要内容提供器来完成。它主要是应用程序之间 实现实时数据交换。 丰富的系统控件 TextView：它主要用于在界面上显示一段文本信息。 Button：是程序用于和用户交互的一个重要组件。 EditText：它允许用户在控件里输入和编辑内容，并在程序中对这些内容进行修改。 ImageView：是用于在界面上展示图片的一种控件。它可以让我们的程序界面变的更加丰富多彩。 ProgressBar：用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。 AlertDialog：可以在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的。 ListView：允许通过手指上下滑的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据将会滚出屏幕。 SQLite数据库 Android系统自带了这种轻量级的、运算速度极快的嵌入式关系型数据库。它不仅支持标准的SQL语法，还可以通过Android封装好的API进行操作，让存储和读取数据变的更加方便。 强大的多媒体 Android系统提供了强大的多媒体服务，如音乐、视频、录音、拍照等，这一切你都可以在程序中通过代码进行控制，让你的应用变的更加丰富多彩。 地理位置定位 基于位置的服务所围绕的核心就是要先确定出用户所在的位置。通常有两种技术方式可以实现：一种是GPS定位，一种是通过网络定位。GPS定位的工作原理是基于手机内置的GPS硬件直接和卫星交互来获取当前的经纬度信息，这种定位方式精确度非常高。但缺点是只能在室外使用，室内基本无法接收到卫星的信号。网络定位的工作原理是根据手机当前网络附近的三个基站进行测速，以此计算出手机和每个基站之间的距离，再通过三角定位确定出一个大概的位置，这种定位方式精确度一般，但优点在于室内你室外都可以时候用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客-让优秀成为一种习惯]]></title>
    <url>%2F2018%2Fcjsokb83l000elwv5htmqqyuu%2F</url>
    <content type="text"><![CDATA[搭建个人博客的必要性现如今的我们处于一个被动接受知识的时代，从书本上获取知识、看一些辅导机构的视频、或者听老师的讲解.自认为从中获得了知识，沾沾自喜。可在真正的实际操作中，才发现自己对这些知识的理解并不是真正的融会贯通，往往处于一种理解概念但不会做题的状态中，也就是人们常说的眼高手低。要解决这个问题，我们首先要学会主动的去获取知识，不能一味地停留在问题表面，学会深入浅出的理解问题，学会思考、总结、以及表达自己的见解。搭建自己的个人博客，不仅可以加深自己对某个问题或者技术的理解，而且可以证明自己的能力，为自己的的学习留下痕迹，再者说，博客可以让人具有更好的总结能力，它本身便是一个很好的简历，是一个用时间和内容来进行面试的严格面试官。 为什么要自己去动手搭建博客系统？个人认为搭建一个属于自己的博客系统，更多的是对一个人的考验。就我个人来说吧，在进行这项工作的过程中便踩过各种各样的坑，从刚开始浏览器不能访问github网站、到SSH Keys的配置、再到中文乱码问题，不断的查资料、看别人写的一些文章、再一步步的尝试，失败了就再换一种方法，有时候解决一个问题便是一早上，甚至一天。最让我崩溃的是在博客系统快搭好的最后一天，在进行最后一步时，在全局配置文件中的一个错误，导致整个网站访问不了，于是将整个配置文件一遍遍检查，去查找错误，然后解决。在整个过程中我觉得自己的耐心、动手操作和解决问题的能力都得到了很大的提高。很多人说博客在于共享，是写给别人看的，可以帮别人解决很多问题；我不否认这个观点，但我认为博客更多的是写给自己看的，它是我们对自身的一个考量。 为自己的初心多一份坚持写博客看似很简单的一件事情，却很少有人能坚持下去，浪费时间、用处不大、没人看等是很多人对写博客的误解，有人曾说过一句话，即使没有读者，我也要写博客。写博客的过程并不是浪费时间，它更像是一种提炼，把你学到的东西总结、升华，从而成为你自己的，坚持写博客对自己是一个很大的提升，可能写一篇体现不出来，坚持写下去，效果是很明显的。要相信：一份耕耘，一份收获。最后，也感谢杨帆师姐的博客文章-搭建个人博客–详细教程。]]></content>
      <categories>
        <category>分享</category>
        <category>个人博客</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2Fcjsokb80j0008lwv519o3j5s1%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
